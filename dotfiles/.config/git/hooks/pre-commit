#!/bin/bash
# Pre-commit hook: validates branch, prevents protected commits, validates submodules, and runs pre-commit
#
# Features:
# 1. Prevents commits to master/main in external repos without push access
# 2. Warns if branch is not based on latest origin/master
# 3. Validates submodule commits exist upstream (prevents CI failures)
# 4. Runs pre-commit with auto-staging (re-stages files modified by formatters)

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Get the hooks directory for sourcing config
HOOK_DIR="$(cd "$(dirname "$0")" && pwd)"

# --- Part 1: Prevent master commits (allowlist approach) ---
# By default, master/main commits are blocked in ALL repos.
# Only repos matching ALLOWED_PATTERNS or detected as agent workspaces are allowed.
BRANCH=$(git branch --show-current 2>/dev/null)
if [ "$BRANCH" = "master" ] || [ "$BRANCH" = "main" ]; then
    REMOTE_URL=$(git remote get-url origin 2>/dev/null || echo "")

    # Source allowed repos from config file (shared with pre-push hook)
    # Falls back to empty array if config doesn't exist (backwards compatible)
    source "$HOOK_DIR/../allowed-repos.conf" 2>/dev/null || ALLOWED_PATTERNS=()

    is_allowed=false

    # Check 1: Explicit allowlist patterns
    for pattern in "${ALLOWED_PATTERNS[@]}"; do
        if [ -n "$pattern" ] && [[ "$REMOTE_URL" == *"$pattern"* ]]; then
            is_allowed=true
            break
        fi
    done

    # Check 2: Auto-detect agent workspace (has gptme.toml with [agent] section)
    if [ "$is_allowed" = false ] && [ -f "gptme.toml" ]; then
        if grep -q '\[agent\]' "gptme.toml" 2>/dev/null; then
            is_allowed=true
        fi
    fi

    # Check 3: Template repo itself (for development)
    if [ "$is_allowed" = false ] && [[ "$REMOTE_URL" == *"gptme-agent-template"* ]]; then
        is_allowed=true
    fi

    if [ "$is_allowed" = false ]; then
        echo -e "${RED}❌ ERROR: Cannot commit directly to $BRANCH${NC}"
        echo "   Repo: $REMOTE_URL"
        echo ""
        echo "   This hook prevents direct master/main commits in external repos."
        echo "   Only agent workspace repos (with gptme.toml [agent] section) are allowed."
        echo ""
        echo "   Please create a feature branch instead:"
        echo "   git checkout -b feature-name origin/$BRANCH"
        echo ""
        echo "   To allow a specific repo, add it to ALLOWED_PATTERNS in:"
        echo "   ~/.config/git/allowed-repos.conf"
        echo ""
        exit 1
    fi
fi

# --- Part 2: Branch base validation (warning only) ---
if [ -x "$HOOK_DIR/validate-branch-base.sh" ]; then
    # Run validation but don't fail on warnings
    "$HOOK_DIR/validate-branch-base.sh" || true
fi

# --- Part 4: Submodule commit validation ---
# Validates that submodule commits exist upstream before committing
# This prevents CI failures from submodules pointing to unpushed commits
if [ -f ".gitmodules" ]; then
    # Find the validation script relative to this hook
    # Hook location: gptme-contrib/dotfiles/.config/git/hooks/pre-commit
    # Need to go 4 levels up: hooks -> git -> .config -> dotfiles -> gptme-contrib
    # Script location: gptme-contrib/scripts/precommit/validate_submodule_commits.py
    GPTME_CONTRIB_DIR="$(cd "$HOOK_DIR/../../../.." && pwd)"
    VALIDATE_SCRIPT="$GPTME_CONTRIB_DIR/scripts/precommit/validate_submodule_commits.py"

    if [ -f "$VALIDATE_SCRIPT" ]; then
        echo -e "${GREEN}Validating submodule commits...${NC}"
        if ! python3 "$VALIDATE_SCRIPT"; then
            echo -e "${RED}✗ Submodule validation failed${NC}"
            echo "   Some submodule commits don't exist upstream."
            echo "   Push your submodule commits before committing the parent repo."
            exit 1
        fi
        echo -e "${GREEN}✓ Submodule commits validated${NC}"
    fi
fi

# --- Part 3: Pre-commit with auto-staging ---
# Only run if repo has pre-commit config
if [ ! -f ".pre-commit-config.yaml" ]; then
    # No pre-commit config, skip this part
    exit 0
fi

# Check if pre-commit is available
if ! command -v pre-commit &> /dev/null; then
    echo -e "${YELLOW}⚠️  pre-commit not found, skipping pre-commit checks${NC}"
    exit 0
fi

echo -e "${GREEN}Running pre-commit checks...${NC}"

# Run pre-commit checks on staged files only
# Capture output to avoid spamming context with passed/skipped hooks
PRECOMMIT_OUTPUT=$(pre-commit run 2>&1)
PRECOMMIT_EXIT=$?

if [ $PRECOMMIT_EXIT -eq 0 ]; then
    echo -e "${GREEN}✓ All pre-commit checks passed${NC}"
    exit 0
else
    # Show output only on failure
    echo "$PRECOMMIT_OUTPUT"
    echo -e "${YELLOW}Pre-commit modified files, checking for auto-staging...${NC}"

    # Check if any files were actually modified
    if git diff --quiet; then
        echo -e "${RED}✗ Pre-commit failed but no files were modified${NC}"
        echo -e "${RED}This indicates a real failure, not auto-fixing${NC}"
        exit 1
    fi

    # Auto-stage modified files
    git add -u

    echo -e "${GREEN}Auto-staged modified files. Re-running pre-commit...${NC}"

    # Re-run pre-commit on staged files
    PRECOMMIT_OUTPUT=$(pre-commit run 2>&1)
    PRECOMMIT_EXIT=$?

    if [ $PRECOMMIT_EXIT -eq 0 ]; then
        echo -e "${GREEN}✓ All pre-commit checks passed after auto-staging${NC}"
        exit 0
    else
        echo "$PRECOMMIT_OUTPUT"
        echo -e "${RED}✗ Pre-commit still failing after auto-staging${NC}"
        exit 1
    fi
fi
