#!/bin/bash
# Pre-push hook: blocks direct pushes to master/main and validates worktree tracking
#
# Install globally:
#   git config --global core.hooksPath ~/.config/git/hooks

SCRIPT_DIR="$(dirname "$0")"

# Store stdin for reuse (git provides: local_ref local_sha remote_ref remote_sha)
# This is needed because we may read stdin in the master/main check
# and need it again for worktree tracking validation
STDIN_CONTENT=$(cat)

# --- Master/Main Push Protection ---
# Source allowed repos from config file (shared with pre-commit hook)
# Falls back to empty array if config doesn't exist (backwards compatible)
source "$SCRIPT_DIR/../allowed-repos.conf" 2>/dev/null || ALLOWED_PATTERNS=()

REMOTE_URL=$(git remote get-url origin 2>/dev/null || echo "")

# Check if repo is in allowed patterns (matches against REMOTE_URL like pre-commit)
is_allowed=false
for pattern in "${ALLOWED_PATTERNS[@]}"; do
    if [ -n "$pattern" ] && [[ "$REMOTE_URL" == *"$pattern"* ]]; then
        is_allowed=true
        break
    fi
done

# Auto-detect agent workspace (has gptme.toml with [agent] section)
if [ "$is_allowed" = false ] && [ -f "gptme.toml" ]; then
    if grep -q '\[agent\]' "gptme.toml" 2>/dev/null; then
        is_allowed=true
    fi
fi

# Template repo itself (for development)
if [ "$is_allowed" = false ] && [[ "$REMOTE_URL" == *"gptme-agent-template"* ]]; then
    is_allowed=true
fi

# If not allowed, check for master/main pushes
if [ "$is_allowed" = false ]; then
    while read _local_ref _local_sha remote_ref _remote_sha; do
        if [[ "$remote_ref" == "refs/heads/master" || "$remote_ref" == "refs/heads/main" ]]; then
            echo "ðŸš« ERROR: Direct push to $remote_ref blocked!"
            echo ""
            echo "This prevents accidental pushes that bypass PR review."
            echo ""
            echo "If intentional, use: git push --no-verify"
            echo "Otherwise, create a branch:"
            echo "  git checkout -b feature-branch"
            echo "  git push -u origin feature-branch"
            exit 1
        fi
    done <<< "$STDIN_CONTENT"
fi

# --- Worktree Tracking Validation ---
# Pass stored stdin to validation script
echo "$STDIN_CONTENT" | "$SCRIPT_DIR/validate-worktree-tracking.sh" "$@"

# Git LFS support (don't fail hook if LFS has issues)
command -v git-lfs >/dev/null 2>&1 && echo "$STDIN_CONTENT" | git lfs pre-push "$@" 2>/dev/null || true
